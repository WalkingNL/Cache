## 高速缓冲池
将近5个月的时间，除了日常的质保，其余时间基本上都压在这个上面了。从零起步，然后是前期的需求调研，到初步方案的确定，再到最终方案落地，单这些就花了有两个月。接下来是代码实现，考虑到对Delphi的使用还不是特别顺手，所以就先用C++实现了一遍，之后再转为Delphi， 确实有点折腾。下面，具体来看一下。

#### 背景介绍
“我们的后台或许不慢了，只是后台的处理动作，被我们在前台感受到了”，我跟领导多次解释这一点。早些时候，投入了大量的精力提升后台的性能，也不负众望，从实际压测的效果来看，足以应对我们所有的需求。但和前台的实际交互效果，令人沮丧。其实，原因已不在后台，也就是说，改后台解决不了前后台交互效率低的问题。如下图所示

![FB.jpg](https://github.com/WalkingNL/Pics/blob/master/FB.jpg)

可以看到，在结构上，前后台是进行直接交互的。只要前台触发一个动作，例如查询3000个数据，后台就会根据这个动作，先进行计算，然后筛选，再排序，最后把结果返回到前台。整个这一套过程可以用下图体现出来。

![](https://github.com/WalkingNL/Pics/blob/master/%E6%8C%87%E4%BB%A4%E6%97%B6%E9%97%B4.jpg)

需要解释一点，为了直观起见，数据的通信过程我单独的用下面的图来呈现。可以看到，前后台的数据交互在一个通道中进行，具体的通信时间由通道本身决定，我们无法对通道进行任何的优化。

![](https://github.com/WalkingNL/Pics/blob/master/%E9%80%9A%E9%81%93.jpg)

总结一下上述过程所用的时间，就是**后台处理数据的时间**，记为t1，加上数据通信的**往返时间**，记为t2，以及其它时间，记为t3，那么总时间T = t1 + t2 + t3。在这里假设t3可以忽略，那么T就由t1和t2来决定，根据以上的描述又知，t1经过了前期的优化，已经达到了期望的时效，那么瓶颈就在t2了，而我们又无法去优化它。

到这里，问题就交代清楚了。怎么解决这个问题，下一小节进行介绍。

#### 缓存原理


#### 实现

#### 后记
