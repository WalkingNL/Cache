## 高速缓冲池
将近5个月的时间，除了日常的质保，其余时间基本上都压在这个上面了。从零起步，然后是前期的需求调研，到初步方案的确定，再到最终方案落地，单这些就花了有两个月。接下来是代码实现，考虑到对Delphi的使用还不是特别顺手，所以就先用C++实现了一遍，之后再转为Delphi， 确实有点折腾。下面，具体来看一下。

#### 背景介绍
“我们的后台或许不慢了，只是后台的处理动作，被我们在前台感受到了”，我跟领导多次解释这一点。早些时候，投入了大量的精力提升后台的性能，也不负众望，从实际压测的效果来看，足以应对我们所有的需求。但和前台的实际交互效果，令人沮丧。其实，原因已不在后台，也就是说，改后台解决不了前后台交互效率低的问题。如下图所示

![FB.jpg](https://github.com/WalkingNL/Pics/blob/master/FB.jpg)

可以看到，在结构上，前后台是进行直接交互的。只要前台触发一个动作，例如查询3000个数据，后台就会根据这个动作，先进行计算，然后筛选，再排序，最后把结果返回到前台。整个这一套过程可以用下图体现出来。

![](https://github.com/WalkingNL/Pics/blob/master/%E6%8C%87%E4%BB%A4%E6%97%B6%E9%97%B4.jpg)

需要解释一点，为了直观起见，数据的通信过程我单独的用下面的图来呈现。可以看到，前后台的数据交互在一个通道中进行，具体的通信时间由通道本身决定，我们无法对通道进行任何的优化。

![](https://github.com/WalkingNL/Pics/blob/master/%E9%80%9A%E9%81%93.jpg)

总结一下上述过程所用的时间，就是**后台处理数据的时间**，记为t1，加上数据通信的**往返时间**，记为t2，以及其它时间，记为t3，那么总时间T = t1 + t2 + t3。在这里假设t3可以忽略，那么T就由t1和t2来决定，根据以上的描述又知，t1经过了前期的优化，已经达到了期望的时效，那么瓶颈就在t2了，而我们又无法去优化它。

到这里，问题就交代清楚了。怎么解决这个问题，下一小节进行介绍。

#### 缓冲池原理
**本质上，缓冲池的加入，并不会改变通道本身的性能，它只是让前后台达到了在时效上的平稳过渡**。
###### 降耦
从上图可知，前后台是强依赖关系，而且通道对我们是一个黑匣子，所以无法对其进行直接优化。但又必须优化，那么很明显的一个策略就是**降偶**。嗯？什么是降偶呢？如下图所示。能够看到，在前台加入了一个缓冲池，让缓冲池作为前后台之间数据交换的一个中间件，这个中间件成为以后前后台交互的**主要渠道**。为什么又是主要渠道呢，从图中能够看出，前后台之间还有一条微弱的联系，如果数据在缓冲池中没找到，就必须到后台去请求数据，所以这条微弱的联系，依然至关重要。这就是降偶，而不是解耦，因为后者意味着这条微弱的联系不存在。但如果那样，数据的完整性恐怕就存在问题了。[注：对于降偶和解耦这两个概念，仅适用于本文]。

#### 缓冲池实现

#### 问题分析

#### 后记
